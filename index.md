## Vue3 相对于 Vue2 做了哪些优化？

- 源码优化

1. 更好的代码管理方式：monorepo(多包管理)
   将不同的模块拆分到不同的 package 中，每个模块的职责划分更明确，模块之间的依赖也更明确，开发人员也更容易阅读、理解和更改所有模块的源码，提高了代码的可维护性。
   另外一些 package 是可以独立使用的，比如 reactivity（响应式），而不需引入完整的库。

2. Typescript(vue2 使用的是 flow)

- 性能优化

1. 源码体积的优化
   移除了一些冷门的 feature（filter、inline-template）
   引入 tree-shaking 的技术，减少打包的体积。（比如项目中没有用到 transition、keep-alive 这些组件，它对应的代码就不会打包）

2. 数据劫持的优化
   Vue2 使用 defineProperty 实现数据劫持，不能检测到对象属性的添加和删除，Vue3 使用 Proxy 劫持整个对象。
   Vue2 在数据初始化的时候，就通过无脑递归的方式，对所有层级的数据都做响应式处理，Vue3 对于深层的数据，只有被访问到才会去做数据劫持，避免了无脑递归。

3. 编译的优化
   Vue 的更新粒度是组件级的，在 patch 的过程中，需要遍历这个组件的 vnode 树，Vue3 通过对静态模板的分析，将 vnode 的更新性能由**与模板整体大小提升为与动态内容的数量有关**
   另外还有事件侦听函数缓存优化，以及 diff 算法的优化。

- 语法 API 优化

1. 优化逻辑组织
   Vue2 组件有 data、props、computed、methods 不同的选项分类，当组件逻辑负载时，修改一个逻辑关注点，往往要上下翻找。
   Vue3 提供一种新的 Composition API，将某个逻辑关注点相关的代码全都放在一个函数里，修改时，不需要上下翻找，也不需要在文件中跳来跳去。

2. 优化逻辑复用
   Vue2 通过 mixin 的方式复用，会存在命名冲突和数据来源不清晰的问题。
   Vue3 通过 hooks 的方式，数据来源更清晰，也不会出现命名冲突。

## 为什么说框架的设计过程其实是一个不断取舍的过程？

Vue 作者尤雨溪在一次演讲中说到：**框架的设计过程其实是一个不断取舍的过程**。

想要搞明白这个，先明确一下概念：

1. 命令式的性能 > 声明式性能
2. 命令式的可维护性 < 声明式的可维护性
3. 声明式的框架本质是由命令式的代码来实现的
4. 企业项目开发时，大多使用的是声明式框架

对于 Vue 而言，当我们使用它是通过 **声明式** 的方式，但是对于 Vue 内部是通过 **命令式** 来实现的，所以我们可以理解为：**Vue 封装了命令式的逻辑，而对外暴露了声明式的接口**

那么既然如此，我们明知 **命令式的性能 > 声明式的性能**。为什么 Vue 还要选择声明式的方案呢？

原因很简单，那就是：**命令式的可维护性 < 声明式的可维护性**

对于 Vue 而言，它所需要做的是：封装命令式的逻辑，同时要**尽可能的减少性能的损耗**，它需要在性能和可维护性之间，找到一个平衡，从而找到一个 **可维护性更好，性能更优的**一个点。

**框架的设计原则其实就是一个不断在可维护性和性能之间进行取舍的过程**

## .vue 文件中的 template 中写的 html 是真实的 html 吗？

不是的。原因很简单，我们写的指令、组件等这些东西，浏览器是不认识的，无法被解析。

但是现实是这些指令或组件被正确解析了，所以 Vue 一定是在中间做了些什么，让假的 html 标签节点渲染成了真实的 html 标签节点。

Vue 在中间做了什么事情呢？

简单来说分成两件事：

1. 编译时：**complier**
2. 运行时：**runtime**

想要学习 Vue 的框架设计，我们必须了解以下三个概念：

1. 运行时：**runtime**（利用 runder 函数，将 vnode 渲染成真实 DOM）
2. 编译时：**complier**（把 template 中的 html 编译成 render 函数）
3. 运行时 + 编译时：**runtime + compiler**（把 template 中的 html 编译成 render 函数 + 利用 runder 函数，将 vnode 渲染成真实 DOM）

## Vue 为什么要设计成一个运行时 + 编译时的框架呢？

想要了解这个问题，我们需要先知道 dom 渲染是如何进行的

对于 dom 渲染而言，可以被分为两部分：

1. 初次渲染，我们可以把它叫做 **挂载**
2. 更新渲染，我们可以把它叫做 **打补丁**

浏览器的更新渲染无非一下两种方式：

1. 删除原有的所有节点，重新渲染新的节点
2. 比对新旧节点，找到最少的操作

我们选择哪一种方式呢？

1. 第一种方式，会涉及到更多的 dom 操作
2. 第二种方式，会涉及到 js 计算 + 少量的 dom 操作

通过实验得知，dom 操作比 js 计算耗时多得多，所以第二种方式更快。

答：

1. 针对于纯运行时而言：因为不存在编译器，所以我们只能提供一个复杂的 js 对象
2. 针对于纯编译时而言：因为缺少运行时，所以只能把分析差异的操作，放到编译时进行，同时因为省略了运行时，所以速度会更快。但是这种方式损失了灵活性
3. 运行时 + 编译时：使其可以在保持灵活性的基础上，尽量的进行性能优化，从而达到一种平衡。

## reactive 的原理以及依赖收集

1. reactive 的本质是用 Proxy 来代理数据，因为是基于 Proxy 的，所以只能代理 **复杂(引用)** 类型的数据
2. 构建了一个 WeakMap 类型的 proxyMap，key 是被代理的对象，值是代理后的对象，作用是，避免同一个对象重复代理
3. 当被代理对象的属性被访问(取值)时，会将对象的 key 和更新视图的 effect 绑定起来
4. 存储依赖的是一个 WeakMap 类型的数据，key 是代理后的对象，value 是一个 Map 类型的数据。Map 的 key 是代理后的对象的属性，Map 的 value 是一个 Dep（依赖），Dep 是一个 Set 类型，存储了更新视图的方法（effect）
5. 当被代理的对象被赋值时，会根据对象的 key 找到对应的 Dep（依赖），依次执行 Dep 中的每一个 effect 的更新视图的方法

## ref 的原理以及依赖收集

1. ref 的本质是构造了一个新的对象，\_value 存储原来的数据，用 value 属性来真正实现数据的访问和修改，所以基于 ref 实现的响应式数据，都需要通过 .value 的形式来访问的
2. \_value 的值分为简单数据类型和引用类型的数据
3. 引用类型的数据，\_value 的值是其实通过 reactive 方法来代理的。所以不管是取值还是修改，都是触发了 Proxy 代理后的 getter ，触发 getter 就进行了依赖收集，依赖收集的时候，会触发 effect 的更新视图的方法
4. 简单数据类型，\_value 的值是原始值，因为取值的时候已经进行了依赖收集，所以修改值的时候，需要去触发依赖

## computed 的原理

1. computed 的本质是构造了一个新的对象，\_value 存储原来的值，用 value 属性来真正实现数据的访问和修改，所以访问 computed 的数据需要通过 .value 的形式
2. 在访问 value 的时候进行依赖收集，并且把对应的 effect 收集到构造的新对象的 dep 属性上
3. 当依赖的值发生改变时，会执行 computed 的 ReactiveEffect 的 scheduler 方法，scheduler 方法内部会触发更新，执行 dep 属性上的 effect 方法更新
4. 内部维护了一个 \_dirty 属性，来实现 computed 的缓存
5. 在执行 dep 的 effects 时，需先执行 computed 的 ReactiveEffect，再执行 effect 的 ReactiveEffect，避免死循环

## Vue3 的 effect 和 Vue2 的 watcher 对比

1. 在 Vue2 中，computed、watch 的本质是 watcher，然后每个组件也有一个渲染 watcher。watcher 会接收一个函数或者 options，options 其实也会转换为对应的函数，watcher 会保存这些函数来更新视图。Vue2 在响应式处理的时候，每一个属性的 getter 中都会 new 一个 Dep 的实例，用来收集 watcher
2. 在 Vue3 中，computed、watch 的本质是 effect，每个组件在渲染的时候，也会初始化一个 effect，effect 也会接收一个函数或者 options，options 其实也会转换为对应的函数，effect 也会保存这些函数来更新视图。

## 单个节点的 props 更新

props 的更新是先遍历新的 vnode 的 props，更新新的 vnode 的 props 的每个属性的值。然后再遍历旧的 vnode 的 props，旧的 props 有的属性，而新的没有的属性就应该被删除。

节点的 props 更新分为几类，class、style、event 和其他属性，其他属性中又分为 HTML Attribute 和 DOM Property。**有些属性只能是通过 DOM Property 的方式设置的**

上述分类的原因是 Vue 对 class 和 style 进行了增强处理，event 事件又是单独特殊处理的

### event

Vue 内部对事件的绑定和解绑，使用了一种 invoker 的机制，即事件的回调函数是保存在 invoker 的 value 属性中，invoker 函数内部执行 invoker 的 value 方法。

这种方式的好处是可以**避免频繁的 addEventListener 和 removeEventListener**，当同一事件的回调函数发生改变的时候，只需修改对应 invoker 的 value 的值，无需先 removeEventListener，再 addEventListener

## 生命周期的原理

在 Vue3 中，兼容了 Vue2 options API 的写法，即生命周期既可以通过 options API 的方式使用，也可以通过 composition API 的方式在 setup 中使用。

1. 在 setup 中使用时，是没有 beforeCreate 和 created 生命周期的，因为这两个生命周期分别是在组件数据初始化之前和之后触发的，setup 中的数据本身已经是通过 ref 和 reactive 定义的响应式数据，无需处理。
2. Vue3 中的生命周期分为两大类，第一类是 beforeCreate 和 created，第二类是除 beforeCreate 和 created 外的其他生命周期。这种分类的原因和 1 一样。
3. Vue3 内部对第二类生命周期的处理，是通过柯里化的思想，在组件挂载之前就注册到组件的实例，然后在组件渲染、更新、卸载等不同的时期，取出之前注册好的生命周期回调执行。(setup 函数的内部可以通过 Vue 暴露出来的生命周期方法注册生命周期，因为此时组件还未挂载)

## 新旧节点的挂载和更新的所有场景

- 旧节点为纯文本：

  1. 新节点为纯文本：执行文本替换操作
  2. 新节点为空时：删除旧的文本节点
  3. 新节点为数组时：清空文本，添加新的子节点

- 旧节点为空时：

  1. 新节点为纯文本：添加新的文本节点
  2. 新节点为空时：不做任何事情
  3. 新节点为数组时：添加新的子节点

- 旧节点为数组时：
  1. 新节点为纯文本：删除旧的所有子节点，添加新的文本节点
  2. 新节点为空时：删除旧的所有子节点
  3. 新节点为数组时：进行 diff 操作

## Vue3 diff 算法核心

Vue3 的 diff 算法还是采用双指针的方式：

1. 头头比对，遇到不是相同的节点就跳出循环。
2. 尾尾比对，遇到不是相同的节点就跳出循环。
3. 如果新的子节点的长度大于旧的子节点的长度，则挂载新的相较于旧的多出来的子节点。
4. 如果新的子节点的长度小于旧的子节点的长度，则卸载旧的相较于新的多出来的子节点。
5. 乱序比对

**乱序比对：**

1. 以新的子节点作映射表，遍历旧的子节点，如果在映射表找到了，则该旧节点可复用，反之，则删除该旧节点。
2. 遍历旧的子节点，根据映射表用数组记录该节点是否可复用，0 表示不可复用，可复用时，值为旧的子节点的索引 + 1（加 1 是避免出现值 0 的情况）。可复用的旧节点打补丁更新 DOM
3. 遍历新的子节点，如果该子节点没有被复用，新增；如果该子节点已经被复用了，判读是否在最长递增子序列中，如果不在，则需要插入

**在头头比对和尾尾比对完之后，只可能是 3、4、5 这三种情况当中的一种**

### 如何高效的移动，才能被复用的旧节点的位置呢？

Vue3 采用了一种最长递增子序列的算法，即找到最长的递增的子序列节点，这些节点的顺序是不需要动的，只需要移动最长的递增的子序列节点外的其他节点，所以做到移动节点数量最少。

## 模板编译

Vue3 的模板编译主要分为以下几步：

1. 将模板编译生成 ast
2. 将 ast 转化为 javascript ast
3. 生成 render 函数

### 模板生成 ast

模板生成 ast 的过程中，有一个有限状态机的概念，即模板在解析的过程中，只会是以下状态：

<!-- <div>hello world</div> -->

- `<` 开始标签开始
- `div` 开始标签名
- `>` 开始标签结束
- `hello world` 文本
- `</` 结束标签开始
- `div` 结束标签名
- `>` 结束标签结束

Vue3 在解析模板的过程中，就是以这些状态为分割点，逐个字符解析，每解析完一个状态，模板的字符串就剔除掉该状态对应的字符串，直到模板的字符串最后为空串。

### 生成 render 函数

1. 根据生成的 javascript ast 拼装 render 函数对应的字符串

- 处理前置代码
- 构建函数名和参数
- 构建函数体

2. 通过 new Function(code) 生成 render 函数
